# 微前端

## 参考链接：

* [微前端如何落地？](https://baijiahao.baidu.com/s?id=1638313846156942854&wfr=spider&for=pc)
* [微前端实践](https://www.jianshu.com/p/41ab812df9e7)
* [基于 qiankun 的微前端最佳实践（万字长文） - 从 0 到 1 篇](https://juejin.im/post/5ebbd2986fb9a0432f0fff86)
* [实施微前端的六种方式](https://segmentfault.com/a/1190000015566927)
* [实现微前端的十种方式 【第一种】](https://blog.csdn.net/petertanjinjie/article/details/107171986)
* [实现微前端的十种方式 【第二种】](https://blog.csdn.net/petertanjinjie/article/details/107218841)
* [微前端框架chunchao(春潮)开源啦](https://blog.csdn.net/petertanjinjie/article/details/106743015)
* [基于 qiankun 的微前端最佳实践（万字长文） - 从 0 到 1 篇](https://mp.weixin.qq.com/s/GjAHSvWqy70s50cwlr9udw)
* [万字长文+图文并茂+全面解析 qiankun 源码 - qiankun 篇](https://www.jianshu.com/p/db08174fa4fc)
* [解密微前端：从qiankun看沙箱隔离](https://blog.csdn.net/mashibing_web/article/details/109903615)
* [基于 qiankun 的微前端最佳实践（图文并茂） - 应用间通信篇](https://blog.csdn.net/qq_34621851/article/details/106003110)
* [基于qiankun的微前端最佳实践-通信篇（Vuex）](https://www.jianshu.com/p/b2a77373c09e)
* [基于qiankun落地部署微前端爬”坑“记](https://blog.csdn.net/u013655559/article/details/107527135)
* [微前端qiankun从搭建到部署的实践](https://www.cnblogs.com/love314159/p/13791556.html)
* [基于 qiankun 的微前端最佳实践（图文并茂） - 应用部署篇](https://blog.csdn.net/mingyuanyunlian/article/details/108766531)
* [关于single-spa的理解和小实战](https://www.jianshu.com/p/54904acb5896)
* [为什么舍弃Iframe探究新的微前端技术？](https://blog.csdn.net/hyupeng1006/article/details/118405388)

## 目录

* [微前端概念](#微前端概念)
* [为什么不使用iframe做微前端](#为什么不使用iframe做微前端)
* [实现方法集合](#实现方法集合)
    * [路由分发式微前端](#路由分发式微前端)
    * [iframe](#iframe)
    * [自制框架](#自制框架)
    * [组合式集成：将应用微件化](#组合式集成：将应用微件化)
    * [纯WebComponents技术构建](#纯WebComponents技术构建)
    * [混用](#混用)
    * [代码](#代码)
* [qiankun](#qiankun)
    * [总流程](#总流程)
    * [使用](#使用)
        * [创建微应用容器](#创建微应用容器)
        * [注册微应用](#注册微应用)
        * [启动主应用](#启动主应用)
        * [接入微应用](#接入微应用)
    * [通信](#通信)
        * [Actions通信](#Actions通信)
        * [Shared通信(redux)](#Shared通信(redux))
        * [Shared通信(vuex)](#Shared通信(vuex))

---

## 微前端概念

* 前提(适用场景)

    项目庞大，多个子项目整合在一个大的项目中。即使子项目的所用的技术栈不同，比如vue,react, angular有相应的的轮子，可以进行整合。

    不适用于：

    1. < ie9 以下的版本
    2. 项目不大型，不需要切分
    3. 项目应用之间没有必然的联系

* 描述

    微服务架构，可以解耦后端服务间依赖。微前端借鉴微服务的概念来应用在前端上，将一个巨大的前端工程拆分成一个的小工程，这些小工程具备独立的开发和运行能力，而整个系统就由这些小工程协同合作。

* 优点

    1. 应用自治。只需要遵循统一的接口规范或者框架，以便于系统集成到一起，相互之间是不存在依赖关系的。
    2. 单一职责。每个前端应用可以只关注于自己所需要完成的功能。
    3. 技术栈无关。你可以使用 Angular 的同时，又可以使用 React 和 Vue。

* 缺点

    1. 应用的拆分基础依赖于基础设施的构建，一旦大量应用依赖于同一基础设施，那么维护变成了一个挑战。
    2. 拆分的粒度越小，便意味着架构变得复杂、维护成本变高。
    3. 技术栈一旦多样化，便意味着技术栈混乱。

* 架构模式

    1. 基座模式。通过一个主应用，来管理其它应用。设计难度小，方便实践，但是通用度低。
    2. 自组织模式。应用之间是平等的，不存在相互管理的模式。设计难度大，不方便实施，但是通用度高。

* 注册表模式

    不论何种方式，都需要提供一个查找应用的机制，在微前端中称为服务的注册表模式。和微服务架构相似，不论是哪种微前端方式，也都需要有一个应用注册表的服务，它可以是一个固定值的配置文件，如 JSON 文件，又或者是一个可动态更新的配置，又或者是一种动态的服务。它主要做这么一些内容：

    1. 应用发现。让主应用可以寻找到其它应用。
    2. 应用注册。即提供新的微前端应用，向应用注册表注册的功能。
    3. 第三方应用注册。即让第三方应用，可以接入到系统中。
    4. 访问权限等相关配置。

* 设计理念

    1. 中心化：应用注册表。这个应用注册表拥有每个应用及对应的入口。在前端领域里，入口的直接表现形式可以是路由，又或者对应的应用映射。
    2. 标识化应用。我们需要一个标识符来标识不同的应用，以便于在安装、卸载的时候，能寻找到指定的应用。一个简单的模式，就是通过康威定律来命名应用。
    3. 应用生命周期管理。
    1. Load，决定加载哪个应用，并绑定生命周期
    2. bootstrap，获取静态资源
    3. Mount，安装应用，如创建 DOM 节点
    4. Unload，删除应用的生命周期
    5. Unmount，卸载应用，如删除 DOM 节点、取消事件绑定
    4. 高内聚，低耦合。

* 技术方式

    1. 路由分发式。通过 HTTP 服务器的反向代理功能，来将请求路由到对应的应用上。
    2. 前端微服务化。在不同的框架之上设计通讯、加载机制，以在一个页面内加载对应的应用。
    3. 微应用。通过软件工程的方式，在部署构建环境中，组合多个独立应用成一个单体应用。
    4. 微件化。开发一个新的构建系统，将部分业务功能构建成一个独立的 chunk 代码，使用时只需要远程加载即可。
    5. 前端容器化。通过将 iFrame 作为容器，来容纳其它前端应用。
    6. 应用组件化。借助于 Web Components 技术，来构建跨框架的前端应用。

* 业务拆分

    1. 按照业务拆分。
    2. 按照权限拆分。
    3. 按照变更的频率拆分。
    4. 按照组织结构拆分。
    5. 跟随后端微服务划分。

* 与传统模式的区别

    1. 应用分发路由 -> 路由分发应用
    2. 后端：函数调用 -> 远程调用
    3. 前端：组件调用 -> 应用调用


* 工具

    chunchao、qiankun

## 为什么不使用iframe做微前端

iframe最大的优点和缺点是隔离性，导致应用间上下文无法被共享。

1. url 不同步。浏览器刷新 iframe 跳转过的 url 状态丢失、后退前进按钮无法使用。
2. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中。
3. 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
4. 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。

## 实现方法集合

### 路由分发式微前端

```nginx
http {
    server {
        listen       80;
        server_name  www.phodal.com;
        location /api/ {
            proxy_pass http://http://172.31.25.15:8000/api;
        }
        location /web/admin {
            proxy_pass http://172.31.25.29/web/admin;
        }
        location /web/notifications {
            proxy_pass http://172.31.25.27/web/notifications;
        }
        location / {
            proxy_pass /;
        }
    }
}
```

### iframe

* 加载机制：应用切换需要过渡平滑
* 通讯机制：通过 iframeEl.contentWindow 去获取 iFrame 元素的 Window 对象是一个更简化的做法

### 自制框架

参考[Mooa](https://github.com/phodal/mooa)

Mooa也是基于iframe，唯一风险是第三方库不兼容

### 组合式集成：将应用微件化

所有的依赖、Pollyfill 已经尽可能地在首次加载了，CSS 样式也不需要重复加载，其他功能再需要加载时，才加载业务组件或应用

方式：归类生成chunk文件，独立开发，集成时合并，运行时加载runtime、代码、模板

限制是必须使用同一框架

### 纯WebComponents技术构建

参考[oan](https://github.com/phodal/oan)

可理解为应用组件化

### 混用

### 代码

1. 最简单的微前端实现方式(乞丐式)

    Vue和React、Jquery共同开发,通信

    babel配置
    ```json
    {
        "presets": [
            "@babel/preset-react",
            [
                "@babel/preset-env",
                {
                    "targets": {
                        "electron": "4"
                    },
                    "modules": false
                }
            ]
        ],
        "plugins": [
            "@babel/plugin-proposal-class-properties",
            "@babel/plugin-syntax-async-generators",
            "@babel/plugin-syntax-dynamic-import"
        ]
    }
    ```

    React的入口
    ```jsx
    import React from 'react';
    import dva from 'dva';
    import App from './App';
    
    import demo from '../App/Dva-model/demo.js';
    const app = dva();
    
    app.model(demo);
    app.router(({ history, app: store }) => (
    <App history={history} getState={store._store.getState} dispatch={store._store.dispatch} />
    ));
    
    app.start('#root');
    ```

    定义vue入口文件
    ```js
    function vueRender(props) {
    new Vue({
        router,
        store,
        render: (h) => h(App),
    }).$mount('#test');
    }
    
    export default vueRender;
    ```

    在React组件中调用vue渲染
    ```js
    import vueRender from '@v/startVUe.js';
    ...
    componentDidMount() {
        vueRender(this.props);
    }
    ```

    这样vue能接受到React组件的props，然后也可以正常通过vue渲染，使用vue的技术栈了

2. 目前主流的微前端实现方式（基座加载式）

    * 劫持前端路由,重写hashchange和popstate事件

        ```js
        const HIJACK_EVENTS_NAME = /^(hashchange|popstate)$/i;
        const EVENTS_POOL = {
        hashchange: [],
        popstate: [],
        };
        
        window.addEventListener('hashchange', loadApps);
        window.addEventListener('popstate', loadApps);
        
        const originalAddEventListener = window.addEventListener;
        const originalRemoveEventListener = window.removeEventListener;
        window.addEventListener = function (eventName, handler) {
        if (
            eventName &&
            HIJACK_EVENTS_NAME.test(eventName) &&
            typeof handler === 'function'
        ) {
            EVENTS_POOL[eventName].indexOf(handler) === -1 &&
            EVENTS_POOL[eventName].push(handler);
        }
        return originalAddEventListener.apply(this, arguments);
        };
        ```
        
    * 根据不同的入口，去拉取子应用的js、css等资源
    * 注册子应用后存入队列中

        ```js
        const Apps = [] //子应用队列
        function registryApp(entry,activeRule) {
            Apps.push({
                entry,
                activeRule
            })
        }
        ```

    * 注册完了之后，就要找到需要加载的app,并且拉取资源

        ```js
        export async function loadApp() {
        const shouldMountApp = Apps.filter(shouldBeActive);
        const App = shouldMountApp.pop();
        fetch(App.entry)
            .then(function (response) {
            return response.text();
            })
            .then(async function (text) {
            const dom = document.createElement('div');
            dom.innerHTML = text;
            const entryPath = App.entry;
            const scripts = dom.querySelectorAll('script');
            const subapp = document.querySelector('#subApp-content');
            const paromiseArr =
                scripts &&
                Array.from(scripts).map((item) => {
                if (item.src) {
                    const url = window.location.protocol + '//' + window.location.host;
                    return fetch(`${entryPath}/${item.src}`.replace(url, '')).then(
                    function (response) {
                        return response.text();
                    }
                    );
                } else {
                    return Promise.resolve(item.textContent);
                }
                });
            subapp.appendChild(dom);
            const res = await Promise.all(paromiseArr);
            if (res && res.length > 0) {
                res.forEach((item) => {
                const script = document.createElement('script');
                script.innerText = item;
                subapp.appendChild(script);
                });
            }
            });
        }
        ```

    * 根据传入的规则去判断是否需要此时挂载

        ```js
        export function shouldBeActive(app){
            return app.activeRule(window.location)
        }
        ```

    * 处理脚本文件

        ```js
        export async function handleScripts(entryPath,subapp,dom) {
            const scripts = dom.querySelectorAll('script');
            const paromiseArr =
                scripts &&
                Array.from(scripts).map((item) => {
                if (item.src) {
                    const url = window.location.protocol + '//' + window.location.host;
                    return fetch(`${entryPath}/${item.src}`.replace(url, '')).then(
                    function (response) {
                        return response.text();
                    }
                    );
                } else {
                    return Promise.resolve(item.textContent);
                }
                });
            const res = await Promise.all(paromiseArr);
            if (res && res.length > 0) {
                res.forEach((item) => {
                const script = document.createElement('script');
                script.innerText = item;
                subapp.appendChild(script);
                });
            }
        }
        ```

    * 处理样式文件

        ```js
        export async function handleStyles(entryPath, subapp, dom) {
            const arr = [];
            const styles = dom.querySelectorAll('style');
            const links = Array.from(dom.querySelectorAll('link')).filter(
                (item) => item.rel === 'stylesheet'
            );
            const realArr = arr.concat(styles,links)
            const paromiseArr =
                arr &&
                Array.from(realArr).map((item) => {
                    if (item.rel) {
                        const url = window.location.protocol + '//' + window.location.host;
                        return fetch(`${entryPath}/${item.href}`.replace(url, '')).then(
                        function (response) {
                            return response.text();
                        }
                        );
                    } else {
                        return Promise.resolve(item.textContent);
                    }
                });
            const res = await Promise.all(paromiseArr);
            if (res && res.length > 0) {
                res.forEach((item) => {
                const style = document.createElement('style');
                style.innerHTML = item;
                subapp.appendChild(style);
                });
            }
        }
        ```

## qiankun

### 总流程

注册子应用->启动主应用->激活并初始化子应用(1次)->挂载子应用(多次)->卸载子应用(多次)

single-spa注册子应用->设置子应用属性(name/callback激活子应用回调/activeRule/props传递给子应用参数)

注入全局变量xx_QIANKUN_，指示子应用正运行在主应用中->初始化配置参数(prefetch是否开启预加载/singularMode是否单例模式/jsSandbox是否开启沙箱)->启动主应用->激活子应用->执行子应用callback->执行生命周期函数(bootstrap/mount/unmount)

初始化子应用->单例模式下，不存在其它相同子应用->通过importEntry加载(fetch)子应用资源->调用子应用render，把html挂载到主容器->创建子应用沙箱sandbox->创建内部生命周期(beforeLoad/beforeMount/afterMount/beforeUnmount/afterUnmount)->指定执行上下文sandbox.proxy，执行子应用脚本execScript->查找子应用提供的3个生命周期(bootstrap/mount/unmount)，没则报错->初始化完毕，等待挂载

沙箱：激活active/关闭inactive/子应用取值getter/子应用设置值setter/当前window状态windowSnapshot，用于还原当前沙箱环境/被修改的属性记录modifyPropsMap，用于还原沙箱激活前状态，清除主应用对主应用全局污染/子应用内部状态池updateValueMap['test']=true

挂载子应用->单例模式下，不存在其它相同子应用->调用子应用render，把html挂载到主容器->触发全局生命周期beforeMount->挂载和激活沙箱，劫持各类全局监听mountSandbox->触发子应用生命周期mount->调用子应用render，loading为false->触发全局生命周期afterMount->设置prevAppUnmountedDeferred，单例模式存活期间，对其它相同子应用阻塞->挂载完成

卸载子应用unmount->触发全局生命周期beforeUnmount->触发子应用生命周期unmount->卸载和关闭沙箱，释放各种全局监听unmountSandbox->触发全局生命周期afterUnmount->调用子应用render，清除主应用html内容->调用prevAppUnmountedDefferred.resolve()不再阻塞其它单例模式下子应用挂载->卸载完成

### 详解沙箱隔离

qiankun 做沙箱隔离主要分为三种：

1. legacySandBox
2. proxySandBox
3. snapshotSandBox

其中 legacySandBox、proxySandBox 是基于 Proxy API 来实现的，在不支持 Proxy API 的低版本浏览器中，会降级为 snapshotSandBox。在现版本中，legacySandBox 仅用于 singular 单实例模式，而多实例模式会使用 proxySandBox。

* legacySandBox

    操作 window 对象，通过激活沙箱时还原子应用的状态，卸载时还原主应用的状态来实现沙箱隔离

    三个状态池：

    * addedPropsMapInSandbox： 存储在子应用运行时期间新增的全局变量，用于卸载子应用时还原主应用全局变量；
    * modifiedPropsOriginalValueMapInSandbox：存储在子应用运行期间更新的全局变量，用于卸载子应用时还原主应用全局变量；
    * currentUpdatedPropsValueMap：存储子应用全局变量的更新，用于运行时切换后还原子应用的状态；

    getter / setter
    ```js
    const rawWindow = window;
    const fakeWindow = Object.create(null) as Window;
    // 创建对fakeWindow的劫持，fakeWindow就是我们传递给自执行函数的window对象
    const proxy = new Proxy(fakeWindow, {
    set(_: Window, p: PropertyKey, value: any): boolean {
        // 运行时的判断
        if (sandboxRunning) {
        // 如果window对象上没有这个属性，那么就在状态池中记录状态的新增；
        if (!rawWindow.hasOwnProperty(p)) {
            addedPropsMapInSandbox.set(p, value);
            // 如果当前 window 对象存在该属性，并且状态池中没有该对象，那么证明改属性是运行时期间更新的值，记录在状态池中用于最后window对象的还原
        } else if (!modifiedPropsOriginalValueMapInSandbox.has(p)) {
            const originalValue = (rawWindow as any)[p];
            modifiedPropsOriginalValueMapInSandbox.set(p, originalValue);
        }
        // 记录全局对象修改值，用于后面子应用激活时还原子应用
        currentUpdatedPropsValueMap.set(p, value);
        (rawWindow as any)[p] = value;
        return true;
        }
        return true;
    },
    get(_: Window, p: PropertyKey): any {
        // iframe的window上下文
        if (p === "top" || p === "window" || p === "self") {
        return proxy;
        }

        const value = (rawWindow as any)[p];
        return getTargetValue(rawWindow, value);
    },
    });
    ```

    激活 / 卸载
    ```js
    // 子应用沙箱激活
    active() {
    // 通过状态池，还原子应用上一次写在前的状态
    if (!this.sandboxRunning) {
        this.currentUpdatedPropsValueMap.forEach((v, p) => setWindowProp(p, v));
    }

    this.sandboxRunning = true;
    }

    // 子应用沙箱卸载
    inactive() {
    // 还原运行时期间修改的全局变量
    this.modifiedPropsOriginalValueMapInSandbox.forEach((v, p) => setWindowProp(p, v));
    // 删除运行时期间新增的全局变量
    this.addedPropsMapInSandbox.forEach((_, p) => setWindowProp(p, undefined, true));

    this.sandboxRunning = false;
    }
    ```

* proxySandBox

    用于多实例场景，某一个子应用聚合了多个业务域，这样的子应用往往会经历多个团队的多个同学共同维护自己的业务模块，这时候便可以采用多实例的模式聚合子模块（这种模式也可以叫微前端模块）

    为了支持多实例的场景，proxySandBox 不会直接操作 window 对象。并且为了避免子应用操作或者修改主应用上诸如 window、document、location 这些重要的属性，会遍历这些属性到子应用 window 副本（fakeWindow）上

    proxySandBox 不直接操作 window，所以在激活和卸载的时候也不需要操作状态池更新 / 还原主子应用的状态了。相比较看来，proxySandBox 是现阶段 qiankun 中最完备的沙箱模式

    ```js
    function createFakeWindow(global: Window) {
    // 这里qiankun给我们了一个知识点：在has和check的场景下，map有着更好的性能 
    const propertiesWithGetter = new Map<PropertyKey, boolean>();
    const fakeWindow = {} as FakeWindow;
    // 从window对象拷贝不可配置的属性
    // 举个例子：window、document、location这些都是挂在Window上的属性，他们都是不可配置的
    // 拷贝出来到fakeWindow上，就间接避免了子应用直接操作全局对象上的这些属性方法
    Object.getOwnPropertyNames(global)
        .filter((p) => {
        const descriptor = Object.getOwnPropertyDescriptor(global, p);
        // 如果属性不存在或者属性描述符的configurable的话
        return !descriptor?.configurable;
        })
        .forEach((p) => {
        const descriptor = Object.getOwnPropertyDescriptor(global, p);
        if (descriptor) {
            // 判断当前的属性是否有getter
            const hasGetter = Object.prototype.hasOwnProperty.call(
            descriptor,
            "get"
            );
            // 为有getter的属性设置查询索引
            if (hasGetter) propertiesWithGetter.set(p, true);
            // freeze the descriptor to avoid being modified by zone.js
            // zone.js will overwrite Object.defineProperty
            // const rawObjectDefineProperty = Object.defineProperty;
            // 拷贝属性到fakeWindow对象上
            rawObjectDefineProperty(fakeWindow, p, Object.freeze(descriptor));
        }
        });
    return {
        fakeWindow,
        propertiesWithGetter,
    };
    }
    ```

    getter/setter
    ```js
    const rawWindow = window;
    // window副本和上面说的有getter的属性的索引
    const { fakeWindow, propertiesWithGetter } = createFakeWindow(rawWindow);
    const descriptorTargetMap = new Map<PropertyKey, SymbolTarget>();
    const hasOwnProperty = (key: PropertyKey) => fakeWindow.hasOwnProperty(key) || rawWindow.hasOwnProperty(key);
    const proxy = new Proxy(fakeWindow, {
    set(target: FakeWindow, p: PropertyKey, value: any): boolean {
        if (sandboxRunning) {
        // 在fakeWindow上设置属性值
        target[p] = value;
        // 记录属性值的变更
        updatedValueSet.add(p);
        // SystemJS属性拦截器
        interceptSystemJsProps(p, value);
        return true;
        }
        // 在 strict-mode 下，Proxy 的 handler.set 返回 false 会抛出 TypeError，在沙箱卸载的情况下应该忽略错误
        return true;
    },
    get(target: FakeWindow, p: PropertyKey): any {
        if (p === Symbol.unscopables) return unscopables;
        // 避免window.window 或 window.self 或window.top 穿透sandbox
        if (p === "top" || p === "window" || p === "self") {
        return proxy;
        }
        if (p === "hasOwnProperty") {
        return hasOwnProperty;
        }
        // 批处理场景下会有场景使用，这里就不多赘述了
        const proxyPropertyGetter = getProxyPropertyGetter(proxy, p);
        if (proxyPropertyGetter) {
        return getProxyPropertyValue(proxyPropertyGetter);
        }
        // 取值
        const value = propertiesWithGetter.has(p)
        ? (rawWindow as any)[p]
        : (target as any)[p] || (rawWindow as any)[p];
        return getTargetValue(rawWindow, value);
    },
    // 还有一些对属性做操作的代码我就不一一列举了，可以自行查阅源码
    });
    ```
    激活 / 卸载
    ```js
    active() {
    this.sandboxRunning = true;
    // 当前激活的子应用沙箱实例数量
    activeSandboxCount++;
    }
    inactive() {
    clearSystemJsProps(this.proxy, --activeSandboxCount === 0);

    this.sandboxRunning = false;
    }
    ```

* snapshotSandBox

    在不支持 Proxy 的场景下会降级为 snapshotSandBox,原理就是在子应用激活 / 卸载时分别去通过快照的形式记录/还原状态来实现沙箱的。

    对当前的 window 和记录的快照做 diff 来实现沙箱
    ```js
    active() {
    if (this.sandboxRunning) {
        return;
    }
    this.windowSnapshot = {} as Window;
    // iter方法就是遍历目标对象的属性然后分别执行回调函数
    // 记录当前快照
    iter(window, prop => {
        this.windowSnapshot[prop] = window[prop];
    });

    // 恢复之前运行时状态的变更
    Object.keys(this.modifyPropsMap).forEach((p: any) => {
        window[p] = this.modifyPropsMap[p];
    });

    this.sandboxRunning = true;
    }

    inactive() {
    this.modifyPropsMap = {};

    iter(window, prop => {
        if (window[prop] !== this.windowSnapshot[prop]) {
        // 记录变更，恢复环境
        this.modifyPropsMap[prop] = window[prop];
        window[prop] = this.windowSnapshot[prop];
        }
    });

    this.sandboxRunning = false;
    }
    ```

* css 隔离

    1. 约定式编程

        * 尽量不要使用可能冲突全局的 class 或者直接为标签定义样式；
        * 定义唯一的 class 前缀，现在的项目都是用诸如 antd 这样的组件库，这类组件库都支持自定义组件 class 前缀；
        * 主应用一定要有自定义的 class 前缀；

    2. css in js:不利于后期的项目维护并且也比较难去抽离一些公共 css

### 使用

* 效果预告

主应用主页基座vue，微应用页vue，微应用页react，微应用页angular

* 将普通的项目改造成 qiankun 主应用基座

1. 创建微应用容器 - 用于承载微应用，渲染显示微应用；
2. 注册微应用 - 设置微应用激活条件，微应用地址等等；
3. 启动 qiankun；

#### 创建微应用容器

1. 设置路由
```ts
// micro-app-main/src/routes/index.ts
import Home from "@/pages/home/index.vue";

const routes = [
    {
    /**
    * path: 路径为 / 时触发该路由规则
    * name: 路由的 name 为 Home
    * component: 触发路由时加载 `Home` 组件
    */
    path: "/",
    name: "Home",
    component: Home,
    },
];

export default routes;
```

2. 主文件引入路由
```ts
// micro-app-main/src/main.ts
//...
import Vue from "vue";
import VueRouter from "vue-router";

import routes from "./routes";

/**
* 注册路由实例
* 即将开始监听 location 变化，触发路由规则
*/
const router = new VueRouter({
    mode: "history",
    routes,
});

// 创建 Vue 实例
// 该实例将挂载/渲染在 id 为 main-app 的节点上
new Vue({
    router,
    render: (h) => h(App),
}).$mount("#main-app");
```

3. 设置主应用的布局
```ts
<template>
    <a-config-provider prefixCls="cns">
    <section id="cns-main-app">
        <section class="cns-menu-wrapper">
        <!-- 主应用菜单，用于渲染菜单 -->
        <main-menu :menus="menus" />
        </section>
        <section class="cns-frame-wrapper">
        <!-- 主应用渲染区，用于挂载主应用路由触发的组件，在触发主应用路由规则时，将渲染主应用的组件 -->
        <router-view v-show="$route.name" />
        <!-- 子应用渲染区，用于挂载子应用节点，在未触发主应用路由规则时，将渲染微应用节点 -->
        <section v-show="!$route.name" id="frame"></section>
        </section>
    </section>
    </a-config-provider prefixCls>
</template>
// micro-app-main/src/App.vue
//...
export default class App extends Vue {
    /**
     * 菜单列表
    * key: 唯一 Key 值
    * title: 菜单标题
    * path: 菜单对应的路径
    */
    menus = [
    {
        key: "Home",
        title: "主页",
        path: "/",
    },
    ];
}
// 省略了样式
```

#### 注册微应用

1. 使用 qiankun 的 registerMicroApps 方法注册微应用
```ts
// micro-app-main/src/micro/apps.ts
// 此时我们还没有微应用，所以 apps 为空
const apps = [];

export default apps;

// micro-app-main/src/micro/index.ts
// 一个进度条插件
import NProgress from "nprogress";
import "nprogress/nprogress.css";
import { message } from "ant-design-vue";
import {
    registerMicroApps,
    addGlobalUncaughtErrorHandler,
    start,
} from "qiankun";

// 微应用注册信息
import apps from "./apps";

/**
* 注册微应用
* 第一个参数 - 微应用的注册信息
* 第二个参数 - 全局生命周期钩子
*/
registerMicroApps(apps, {
    // qiankun 生命周期钩子 - 微应用加载前
    beforeLoad: (app: any) => {
    // 加载微应用前，加载进度条
    NProgress.start();
    console.log("before load", app.name);
    return Promise.resolve();
    },
    // qiankun 生命周期钩子 - 微应用挂载后
    afterMount: (app: any) => {
    // 加载微应用前，进度条加载完成
    NProgress.done();
    console.log("after mount", app.name);
    return Promise.resolve();
    },
});

/**
* 添加全局的未捕获异常处理器
*/
addGlobalUncaughtErrorHandler((event: Event | string) => {
    console.error(event);
    const { message: msg } = event as any;
    // 加载失败时提示
    if (msg && msg.includes("died in status LOADING_SOURCE_CODE")) {
    message.error("微应用加载失败，请检查应用是否可运行");
    }
});

// 导出 qiankun 的启动函数
export default start;
```

#### 启动主应用

1. 入口文件启动 qiankun 主应用
```js
// micro-app-main/src/main.ts
//...
import startQiankun from "./micro";

startQiankun();
```

#### 接入微应用

qiankun 内部通过 import-entry-html 加载微应用，要求微应用需要导出生命周期钩子函数:bootstrap/mount/unmount，如果微应用没有导出这三个生命周期钩子函数，则微应用会加载失败。

如果我们使用了脚手架搭建微应用的话，我们可以通过 webpack 配置在入口文件处导出这三个生命周期钩子函数。如果没有使用脚手架的话，也可以直接在微应用的 window 上挂载这三个生命周期钩子函数。

1. 接入 Vue 微应用

    * 创建vue项目(主应用的同级目录（micro-app-main 同级目录）)：vue create micro-app-vue
    * 创建几个路由、页面，写样式
    * 在主应用中注册该微应用的信息(接上面app.ts),进入 /vue 路由时将加载 Vue 微应用

        ```ts
        // micro-app-main/src/micro/apps.ts
        const apps = [
            /**
             * name: 微应用名称 - 具有唯一性
            * entry: 微应用入口 - 通过该地址加载微应用
            * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上
            * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
            */
            {
            name: "VueMicroApp",
            entry: "//localhost:10200",
            container: "#frame",
            activeRule: "/vue",
            },
        ];

        export default apps;
        ```

    * 菜单配置处也加入 Vue 微应用的快捷入口

        ```ts
        // micro-app-main/src/App.vue
        //...
        export default class App extends Vue {
            /**
             * 菜单列表
            * key: 唯一 Key 值
            * title: 菜单标题
            * path: 菜单对应的路径
            */
            menus = [
            {
                key: "Home",
                title: "主页",
                path: "/",
            },
            {
                key: "VueMicroApp",
                title: "Vue 主页",
                path: "/vue",
            },
            {
                key: "VueMicroAppList",
                title: "Vue 列表页",
                path: "/vue/list",
            },
            ];
        }
        ```

    * 导出 qiankun 主应用所需要的三个生命周期钩子函数

        ```ts
        // micro-app-vue/src/public-path.js
        if (window.__POWERED_BY_QIANKUN__) {
            // 动态设置 webpack publicPath，防止资源加载出错
            // eslint-disable-next-line no-undef
            __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
        }

        // micro-app-vue/src/main.js
        import Vue from "vue";
        import VueRouter from "vue-router";
        import Antd from "ant-design-vue";
        import "ant-design-vue/dist/antd.css";

        import "./public-path";//webpack 默认的 publicPath 为 "" 空字符串，会基于当前路径来加载资源。我们在主应用中加载微应用时需要重新设置 publicPath，这样才能正确加载微应用的相关资源。（public-path.js 具体实现在后面）
        import App from "./App.vue";
        import routes from "./routes";

        Vue.use(VueRouter);
        Vue.use(Antd);
        Vue.config.productionTip = false;

        let instance = null;
        let router = null;

        //微应用的挂载函数，在主应用中运行时将在 mount 生命周期钩子函数中调用，可以保证在沙箱内运行。
        /**
        * 渲染函数
        * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行
        */
        function render() {
            // 在 render 中创建 VueRouter，可以保证在卸载微应用时，移除 location 事件监听，防止事件污染
            router = new VueRouter({
            // 运行在主应用中时，添加路由命名空间 /vue
            base: window.__POWERED_BY_QIANKUN__ ? "/vue" : "/",
            mode: "history",
            routes,
            });

            // 挂载应用
            instance = new Vue({
            router,
            render: (h) => h(App),
            }).$mount("#app");
        }

        //微应用独立运行时，直接执行 render 函数挂载微应用。
        // 独立运行时，直接挂载应用
        if(!window.__POWER_BY_QIANKUN__){
            render()
        }

        //微应用导出的生命周期钩子函数 - bootstrap
        /**
        * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
        * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
        */
        export async function bootstrap() {
            console.log("VueMicroApp bootstraped");
        }

        //微应用导出的生命周期钩子函数 - mount
        /**
        * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
        */
        export async function mount(props) {
            console.log("VueMicroApp mount", props);
            render(props);
        }

        //微应用导出的生命周期钩子函数 - unmount
        /**
        * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
        */
        export async function unmount() {
            console.log("VueMicroApp unmount");
            instance.$destroy();
            instance = null;
            router = null;
        }
        ```

    * 配置 vue.config.js,配置 webpack，使 main.js 导出的生命周期钩子函数可以被 qiankun 识别获取。

        ```js
        // micro-app-vue/vue.config.js
        const path = require("path");

        module.exports = {
            devServer: {
            // 监听端口
            port: 10200,
            // 关闭主机检查，使微应用可以被 fetch
            disableHostCheck: true,
            // 配置跨域请求头，解决开发环境的跨域问题
            headers: {
                "Access-Control-Allow-Origin": "*",
            },
            },
            configureWebpack: {
            resolve: {
                alias: {
                "@": path.resolve(__dirname, "src"),
                },
            },
            output: {
                // 微应用的包名，这里与主应用中注册的微应用名称一致
                library: "VueMicroApp",
                // 将你的 library 暴露为所有的模块定义下都可运行的方式
                libraryTarget: "umd",
                // 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可
                jsonpFunction: `webpackJsonp_VueMicroApp`,
            },
            },
        };
        ```

    * 打开主基座，切换到vue微应用，能正确加载，控制台能看到执行的生命周期钩子

2. 接入react应用

    * 创建react项目(在主应用的同级目录（micro-app-main 同级目录）):npx create-react-app micro-app-react,添加 .env 文件，设置项目监听的端口

        ```txt
        # micro-app-react/.env
        PORT=10100
        BROWSER=none
        ```

    * 创建几个路由、页面，加入样式
    * 主应用中注册该微应用的信息

        ```ts
        // micro-app-main/src/micro/apps.ts
        const apps = [
            /**
             * name: 微应用名称 - 具有唯一性
            * entry: 微应用入口 - 通过该地址加载微应用
            * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上
            * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
            */
            {
            name: "ReactMicroApp",
            entry: "//localhost:10100",
            container: "#frame",
            activeRule: "/react",
            },
        ];

        export default apps;
        ```

    * 菜单配置处也加入 React 微应用的快捷入口

        ```ts
        // micro-app-main/src/App.vue
        //...
        export default class App extends Vue {
            /**
             * 菜单列表
            * key: 唯一 Key 值
            * title: 菜单标题
            * path: 菜单对应的路径
            */
            menus = [
            {
                key: "Home",
                title: "主页",
                path: "/",
            },
            {
                key: "ReactMicroApp",
                title: "React 主页",
                path: "/react",
            },
            {
                key: "ReactMicroAppList",
                title: "React 列表页",
                path: "/react/list",
            },
            ];
        }
        ```

    * 在 React 的入口文件 index.js 中，导出 qiankun 主应用所需要的三个生命周期钩子函数

        ```ts
        // micro-app-react/src/public-path.js
        if (window.__POWERED_BY_QIANKUN__) {
            // 动态设置 webpack publicPath，防止资源加载出错
            // eslint-disable-next-line no-undef
            __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
        }

        // micro-app-react/src/index.js
        import React from "react";
        import ReactDOM from "react-dom";
        import "antd/dist/antd.css";

        import "./public-path";
        import App from "./App.jsx";

        /**
        * 渲染函数
        * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行
        */
        function render() {
            ReactDOM.render(<App />, document.getElementById("root"));
        }

        // 独立运行时，直接挂载应用
        if (!window.__POWERED_BY_QIANKUN__) {
            render();
        }

        /**
        * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
        * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
        */
        export async function bootstrap() {
            console.log("ReactMicroApp bootstraped");
        }

        /**
        * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
        */
        export async function mount(props) {
            console.log("ReactMicroApp mount", props);
            render(props);
        }

        /**
        * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
        */
        export async function unmount() {
            console.log("ReactMicroApp unmount");
            ReactDOM.unmountComponentAtNode(document.getElementById("root"));
        }
        ```

    * 配置路由命名空间，以确保主应用可以正确加载微应用

        ```ts
        // micro-app-react/src/App.jsx
        const BASE_NAME = window.__POWERED_BY_QIANKUN__ ? "/react" : "";
        const App = () => {
            //...

            return (
            // 设置路由命名空间
            <Router basename={BASE_NAME}>{/* ... */}</Router>
            );
        };
        ```

    * 配置 webpack，使 index.js 导出的生命周期钩子函数可以被 qiankun 识别获取。借助 react-app-rewired 来帮助我们修改 webpack 的配置

        npm install react-app-rewired -D
        ```json
        // micro-app-react/package.json

        //...
        "scripts": {
            "start": "react-app-rewired start",
            "build": "react-app-rewired build",
            "test": "react-app-rewired test",
            "eject": "react-app-rewired eject"
        }
        ```

        新建 config-overrides.js 文件来配置 webpack
        ```ts
        const path = require("path");

        module.exports = {
            webpack: (config) => {
            // 微应用的包名，这里与主应用中注册的微应用名称一致
            config.output.library = `ReactMicroApp`;
            // 将你的 library 暴露为所有的模块定义下都可运行的方式
            config.output.libraryTarget = "umd";
            // 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可
            config.output.jsonpFunction = `webpackJsonp_ReactMicroApp`;

            config.resolve.alias = {
                ...config.resolve.alias,
                "@": path.resolve(__dirname, "src"),
            };
            return config;
            },

            devServer: function (configFunction) {
            return function (proxy, allowedHost) {
                const config = configFunction(proxy, allowedHost);
                // 关闭主机检查，使微应用可以被 fetch
                config.disableHostCheck = true;
                // 配置跨域请求头，解决开发环境的跨域问题
                config.headers = {
                "Access-Control-Allow-Origin": "*",
                };
                // 配置 history 模式
                config.historyApiFallback = true;

                return config;
            };
            },
        };
        ```

    * 打开主基座，切换到react微应用，能正确加载，控制台能看到执行的生命周期钩子

3. 接入 Angular 微应用

    * 创建angular项目(主应用的同级目录（micro-app-main 同级目录）):ng new micro-app-angular
    * 创建路由、页面，加入样式
    * 注册微应用

        ```ts
        // micro-app-main/src/micro/apps.ts
        const apps = [
            /**
             * name: 微应用名称 - 具有唯一性
            * entry: 微应用入口 - 通过该地址加载微应用
            * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上
            * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
            */
            {
            name: "AngularMicroApp",
            entry: "//localhost:10300",
            container: "#frame",
            activeRule: "/angular",
            },
        ];

        export default apps;
        ```

    * 菜单配置处也加入 Angular 微应用的快捷入口

        ```ts
        // micro-app-main/src/App.vue
        //...
        export default class App extends Vue {
            /**
             * 菜单列表
            * key: 唯一 Key 值
            * title: 菜单标题
            * path: 菜单对应的路径
            */
            menus = [
            {
                key: "Home",
                title: "主页",
                path: "/",
            },
            {
                key: "AngularMicroApp",
                title: "Angular 主页",
                path: "/angular",
            },
            {
                key: "AngularMicroAppList",
                title: "Angular 列表页",
                path: "/angular/list",
            },
            ];
        }
        ```

    * 在主应用注入 zone.js

        ```ts
        // micro-app-main/src/main.js
        // 为 Angular 微应用所做的 zone 包注入
        import "zone.js/dist/zone";
        ```
        * 配置微应用,使用 single-spa-angular 生成一套配置:ng add single-spa-angular
        * 导出 qiankun 主应用所需要的三个生命周期钩子函数
        ```ts
        // micro-app-angular/src/main.single-spa.ts
        import { enableProdMode, NgZone } from "@angular/core";

        import { platformBrowserDynamic } from "@angular/platform-browser-dynamic";
        import { Router } from "@angular/router";
        import { ɵAnimationEngine as AnimationEngine } from "@angular/animations/browser";

        import {
            singleSpaAngular,
            getSingleSpaExtraProviders,
        } from "single-spa-angular";

        import { AppModule } from "./app/app.module";
        import { environment } from "./environments/environment";
        import { singleSpaPropsSubject } from "./single-spa/single-spa-props";

        if (environment.production) {
            enableProdMode();
        }

        // 微应用单独启动时运行
        if (!(window as any).__POWERED_BY_QIANKUN__) {
            platformBrowserDynamic()
            .bootstrapModule(AppModule)
            .catch((err) => console.error(err));
        }

        const { bootstrap, mount, unmount } = singleSpaAngular({
            bootstrapFunction: (singleSpaProps) => {
            singleSpaPropsSubject.next(singleSpaProps);
            return platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule(
                AppModule
            );
            },
            template: "<app-root />",
            Router,
            NgZone,
            AnimationEngine,
        });

        /** 主应用生命周期钩子中运行 */
        export {
            /**
             * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
            * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
            */
            bootstrap,
            /**
             * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
            */
            mount,
            /**
             * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
            */
            unmount,
        };
        ```

    * 配置 webpack，使 main.single-spa.ts 导出的生命周期钩子函数可以被 qiankun 识别获取,直接配置 extra-webpack.config.js
    
        ```ts
        // micro-app-angular/extra-webpack.config.js
        const singleSpaAngularWebpack = require("single-spa-angular/lib/webpack")
            .default;
        const webpackMerge = require("webpack-merge");

        module.exports = (angularWebpackConfig, options) => {
            const singleSpaWebpackConfig = singleSpaAngularWebpack(
            angularWebpackConfig,
            options
            );

            const singleSpaConfig = {
            output: {
                // 微应用的包名，这里与主应用中注册的微应用名称一致
                library: "AngularMicroApp",
                // 将你的 library 暴露为所有的模块定义下都可运行的方式
                libraryTarget: "umd",
            },
            };
            const mergedConfig = webpackMerge.smart(
            singleSpaWebpackConfig,
            singleSpaConfig
            );
            return mergedConfig;
        };
        ```

    * 修改一下 package.json 中的启动命令

        ```json
        // micro-app-angular/package.json
        {
            //...
            "script": {
            //...
            // --disable-host-check: 关闭主机检查，使微应用可以被 fetch
            // --port: 监听端口
            // --base-href: 站点的起始路径，与主应用中配置的一致
            "start": "ng serve --disable-host-check --port 10300 --base-href /angular"
            }
        }
        ```

    * 打开主基座，切换到angular微应用，能正确加载，控制台能看到执行的生命周期钩子

4. 接入 jquery 等其它微应用

    * 在主应用的同级目录（micro-app-main 同级目录），手动创建目录 micro-app-static
    * 使用 express 作为服务器加载静态 html，我们先编辑 package.json，设置启动命令和相关依赖。

        ```json
        // micro-app-static/package.json
        {
            "name": "micro-app-jquery",
            "version": "1.0.0",
            "description": "",
            "main": "index.js",
            "scripts": {
            "start": "nodemon index.js"
            },
            "author": "",
            "license": "ISC",
            "dependencies": {
            "express": "^4.17.1",
            "cors": "^2.8.5"
            },
            "devDependencies": {
            "nodemon": "^2.0.2"
            }
        }
        ```

    * 添加入口文件 index.js

        ```js
        // micro-app-static/index.js
        const express = require("express");
        const cors = require("cors");

        const app = express();
        // 解决跨域问题
        app.use(cors());
        app.use('/', express.static('static'));

        // 监听端口
        app.listen(10400, () => {
            console.log("server is listening in http://localhost:10400")
        });
        ```

    * npm install 安装相关依赖后，使用 npm start 启动应用
    * 注册微应用

        ```ts
        // micro-app-main/src/micro/apps.ts
        const apps = [
            /**
             * name: 微应用名称 - 具有唯一性
            * entry: 微应用入口 - 通过该地址加载微应用
            * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上
            * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
            */
            {
            name: "StaticMicroApp",
            entry: "//localhost:10400",
            container: "#frame",
            activeRule: "/static"
            },
        ];

        export default apps;
        ```

    * 菜单配置处也加入 Static 微应用的快捷入口

        ```ts
        // micro-app-main/src/App.vue
        //...
        export default class App extends Vue {
            /**
             * 菜单列表
            * key: 唯一 Key 值
            * title: 菜单标题
            * path: 菜单对应的路径
            */
            menus = [
            {
                key: "Home",
                title: "主页",
                path: "/"
            },
            {
                key: "StaticMicroApp",
                title: "Static 微应用",
                path: "/static"
            }
            ];
        }
        ```

    * 配置微应用,新建 static 文件夹，在文件夹内新增一个静态页面 index.html

        ```html
        <!-- micro-app-static/static/index.html -->
        <!DOCTYPE html>
        <html lang="en">
            <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <meta http-equiv="X-UA-Compatible" content="ie=edge" />
            <!-- 引入 bootstrap -->
            <link
                href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css"
                rel="stylesheet"
            />
            <title>Jquery App</title>
            </head>

            <body>
            <section
                id="jquery-app-container"
                style="padding: 20px; color: blue;"
            ></section>
            </body>
            <!-- 引入 jquery -->
            <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            <script>
            /**
            * 请求接口数据，构建 HTML
            */
            async function buildHTML() {
                const result = await fetch("http://dev-api.jt-gmall.com/mall", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                // graphql 的查询风格
                body: JSON.stringify({
                    query: `{ vegetableList (page: 1, pageSize: 20) { page, pageSize, total, items { _id, name, poster, price } } }`,
                }),
                }).then((res) => res.json());
                const list = result.data.vegetableList.items;
                const html = `<table class="table">
                <thead>
                    <tr>
                    <th scope="col">菜名</th>
                    <th scope="col">图片</th>
                    <th scope="col">报价</th>
                    </tr>
                </thead>
                <tbody>
                    ${list
                    .map(
                        (item) => `
                    <tr>
                    <td>
                        <img style="width: 40px; height: 40px; border-radius: 100%;" src="${item.poster}"></img>
                    </td>
                    <td>${item.name}</td>
                    <td>￥ ${item.price}</td>
                    </tr>
                    `
                    )
                    .join("")}
                </tbody>
                </table>`;
                return html;
            }

            /**
            * 渲染函数
            * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行
            */
            const render = async ($) => {
                const html = await buildHTML();
                $("#jquery-app-container").html(html);
                return Promise.resolve();
            };

            // 独立运行时，直接挂载应用
            if (!window.__POWERED_BY_QIANKUN__) {
                render($);
            }

            ((global) => {
                /**
                 * 注册微应用生命周期钩子函数
                * global[appName] 中的 appName 与主应用中注册的微应用名称一致
                */
                global["StaticMicroApp"] = {
                /**
                * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
                * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
                */
                bootstrap: () => {
                    console.log("MicroJqueryApp bootstraped");
                    return Promise.resolve();
                },
                /**
                * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
                */
                mount: () => {
                    console.log("MicroJqueryApp mount");
                    return render($);
                },
                /**
                * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
                */
                unmount: () => {
                    console.log("MicroJqueryApp unmount");
                    return Promise.resolve();
                },
                };
            })(window);
            </script>
        </html>
        ```

    * 打开主基座，切换到static微应用，能正确加载，控制台能看到执行的生命周期钩子

### 通信

1. 官方提供的通信方式 - Actions 通信，适合业务划分清晰，比较简单的微前端应用，一般来说可以满足大部分的应用场景需求
2. 基于 redux 实现的通信方式 - Shared 通信，适合需要跟踪通信状态，子应用具备独立运行能力，较为复杂的微前端应用
3. 使用Vuex来进行状态管理，这其实是对于上面通信方式中，第二种方式的补充

#### Actions通信

* Actions 通信优点：

1. 使用简单；
2. 官方支持性高；
3. 适合通信较少的业务场景；

* 缺点：

1. 子应用独立运行时，需要额外配置无 Actions 时的逻辑；
2. 子应用需要先了解状态池的细节，再进行通信；
3. 由于状态池无法跟踪，通信场景较多时，容易出现状态混乱、维护困难等问题；

qiankun 内部提供了 initGlobalState 方法用于注册 MicroAppStateActions 实例用于通信，该实例有三个方法，分别是：

* setGlobalState：设置 globalState - 设置新的值时，内部将执行 浅检查，如果检查到 globalState 发生改变则触发通知，通知到所有的 观察者 函数。
* onGlobalStateChange：注册 观察者 函数 - 响应 globalState 变化，在 globalState 发生改变时触发该 观察者 函数。
* offGlobalStateChange：取消 观察者 函数 - 该实例不再响应 globalState 变化。

实战

* 主应用

1. 在主应用中注册一个 MicroAppStateActions 实例并导出
```ts
// micro-app-main/src/shared/actions.ts
import { initGlobalState, MicroAppStateActions } from "qiankun";

const initialState = {};
const actions: MicroAppStateActions = initGlobalState(initialState);

export default actions;
```

2. 在需要通信的组件中使用该实例，并注册 观察者 函数，以登录功能为例

在 Vue 组件 的 mounted 生命周期钩子函数中注册了一个 观察者 函数，然后定义了一个 login 方法，最后将 login 方法绑定在按钮中
```ts
// micro-app-main/src/pages/login/index.vue
import actions from "@/shared/actions";
import { ApiLoginQuickly } from "@/apis";

@Component
export default class Login extends Vue {
    $router!: VueRouter;

    // `mounted` 是 Vue 的生命周期钩子函数，在组件挂载时执行
    mounted() {
    // 注册一个观察者函数
    actions.onGlobalStateChange((state, prevState) => {
        // state: 变更后的状态; prevState: 变更前的状态
        console.log("主应用观察者：token 改变前的值为 ", prevState.token);
        console.log("主应用观察者：登录状态发生改变，改变后的 token 的值为 ", state.token);
    });
    }
    
    async login() {
    // ApiLoginQuickly 是一个远程登录函数，用于获取 token，详见 Demo
    const result = await ApiLoginQuickly();
    const { token } = result.data.loginQuickly;

    // 登录成功后，设置 token
    actions.setGlobalState({ token });

    //在登录后跳转到主页
    this.$router.push("/");
    }
}
```

3. 点击 2 次按钮

    * 第一次点击：原 token 值为 undefined，新 token 值为我们最新设置的值；
    * 第二次点击时：原 token 的值是我们上一次设置的值，新 token 值为我们最新设置的值；

* 子应用

上面已经完成了主应用的登录功能，将 token 信息记录在了 globalState 中。现在，我们进入子应用，使用 token 获取用户信息并展示在页面中。

1. 改造 Vue 子应用，设置一个 Actions 实例
```ts
// micro-app-vue/src/shared/actions.js
function emptyAction() {
    // 警告：提示当前使用的是空 Action
    console.warn("Current execute action is empty!");
}

class Actions {
    // 默认值为空 Action
    actions = {
    onGlobalStateChange: emptyAction,
    setGlobalState: emptyAction
    };
    
    /**
        * 设置 actions
    */
    setActions(actions) {
    this.actions = actions;
    }

    /**
        * 映射
    */
    onGlobalStateChange(...args) {
    return this.actions.onGlobalStateChange(...args);
    }

    /**
        * 映射
    */
    setGlobalState(...args) {
    return this.actions.setGlobalState(...args);
    }
}

const actions = new Actions();
export default actions;
```

2. 在入口文件 main.js 的 render 函数中注入真实 Actions
```ts
// micro-app-vue/src/main.js
//...

/**
* 渲染函数
* 主应用生命周期钩子中运行/子应用单独启动时运行
*/
function render(props) {
    if (props) {
    // 注入 actions 实例
    actions.setActions(props);
    }

    router = new VueRouter({
    base: window.__POWERED_BY_QIANKUN__ ? "/vue" : "/",
    mode: "history",
    routes,
    });

    // 挂载应用
    instance = new Vue({
    router,
    render: (h) => h(App),
    }).$mount("#app");
}
```

3. 在子应用的 通讯页 获取 globalState 中的 token，使用 token 来获取用户信息，最后在页面中显示用户信息
```ts
// micro-app-vue/src/pages/communication/index.vue
// 引入 actions 实例
import actions from "@/shared/actions";
import { ApiGetUserInfo } from "@/apis";

export default {
    name: "Communication",

    data() {
    return {
        userInfo: {}
    };
    },

    mounted() {
    // 注册观察者函数
    // onGlobalStateChange 第二个参数为 true，表示立即执行一次观察者函数
    actions.onGlobalStateChange(state => {
        const { token } = state;
        // 未登录 - 返回主页
        if (!token) {
        this.$message.error("未检测到登录信息！");
        return this.$router.push("/");
        }

        // 获取用户信息
        this.getUserInfo(token);
    }, true);
    },

    methods: {
    async getUserInfo(token) {
        // ApiGetUserInfo 是用于获取用户信息的函数
        const result = await ApiGetUserInfo(token);
        this.userInfo = result.data.getUserInfo;
    }
    }
};
```

#### Shared通信(redux)

Shared 通信方案的原理就是，主应用基于 redux 维护一个状态池，通过 shared 实例暴露一些方法给子应用使用。同时，子应用需要单独维护一份 shared 实例，在独立运行时使用自身的 shared 实例，在嵌入主应用时使用主应用的 shared 实例，这样就可以保证在使用和表现上的一致性。

Shared 通信方案需要自行维护状态池，这样会增加项目的复杂度。好处是可以使用市面上比较成熟的状态管理工具，如 redux、mobx，可以有更好的状态管理追踪和一些工具集。

Shared 通信方案要求父子应用都各自维护一份属于自己的 shared 实例，同样会增加项目的复杂度。好处是子应用可以完全独立于父应用运行（不依赖状态池），子应用也能以最小的改动被嵌入到其他 第三方应用 中。

Shared 通信方案也可以帮助主应用更好的管控子应用。子应用只可以通过 shared 实例来操作状态池，可以避免子应用对状态池随意操作引发的一系列问题。主应用的 Shared 相对于子应用来说是一个黑箱，子应用只需要了解 Shared 所暴露的 API 而无需关心实现细节。

* 优点

1. 可以自由选择状态管理库，更好的开发体验。 - 比如 redux 有专门配套的开发工具可以跟踪状态的变化。
2. 子应用无需了解主应用的状态池实现细节，只需要了解 shared 的函数抽象，实现一套自身的 shared 甚至空 shared 即可，可以更好的规范子应用开发。
3. 子应用无法随意污染主应用的状态池，只能通过主应用暴露的 shared 实例的特定方法操作状态池，从而避免状态池污染产生的问题。
4. 子应用将具备独立运行的能力，Shared 通信使得父子应用有了更好的解耦性。

* 缺点

1. 主应用需要单独维护一套状态池，会增加维护成本和项目复杂度；
2. 子应用需要单独维护一份 shared 实例，会增加维护成本；

实战

* 主应用

1. 在主应用中创建 store 用于管理全局状态池
```ts
// micro-app-main/src/shared/store.ts
import { createStore } from "redux";

export type State = {
    token?: string;
};

type Action = {
    type: string;
    payload: any;
};

const reducer = (state: State = {}, action: Action): State => {
    switch (action.type) {
    default:
        return state;
    // 设置 Token
    case "SET_TOKEN":
        return {
        ...state,
        token: action.payload,
        };
    }
};

const store = createStore<State, Action, unknown, unknown>(reducer);

export default store;
```

2. 主应用的 shared 实例
```ts
// micro-app-main/src/shared/index.ts
import store from "./store";

class Shared {
    /**
        * 获取 Token
    */
    public getToken(): string {
    const state = store.getState();
    return state.token || "";
    }

    /**
        * 设置 Token
    */
    public setToken(token: string): void {
    // 将 token 的值记录在 store 中
    store.dispatch({
        type: "SET_TOKEN",
        payload: token
    });
    }
}

const shared = new Shared();
export default shared;
```

3. 修改登录组件的login方法
```ts
// micro-app-main/src/pages/login/index.vue
// ...
async login() {
    // ApiLoginQuickly 是一个远程登录函数，用于获取 token，详见 Demo
    const result = await ApiLoginQuickly();
    const { token } = result.data.loginQuickly;

    // 使用 shared 的 setToken 方法记录 token
    shared.setToken(token);
    this.$router.push("/");
}
```

4. 将 shared 实例通过 props 传递给子应用
```ts
// micro-app-main/src/micro/apps.ts
import shared from "@/shared";

const apps = [
    {
    name: "ReactMicroApp",
    entry: "//localhost:10100",
    container: "#frame",
    activeRule: "/react",
    // 通过 props 将 shared 传递给子应用
    props: { shared },
    },
    {
    name: "VueMicroApp",
    entry: "//localhost:10200",
    container: "#frame",
    activeRule: "/vue",
    // 通过 props 将 shared 传递给子应用
    props: { shared },
    },
];

export default apps;
```

* 子应用

1. 子应用也应该实现 shared，以便在独立运行时可以拥有兼容处理能力
```ts
// micro-app-vue/src/shared/index.js
//子应用自身的 shared，子应用独立运行时将使用该 shared，子应用的 shared 使用 localStorage 来操作 token
class Shared {
    /**
        * 获取 Token
    */
    getToken() {
    // 子应用独立运行时，在 localStorage 中获取 token
    return localStorage.getItem("token") || "";
    }

    /**
        * 设置 Token
    */
    setToken(token) {
    // 子应用独立运行时，在 localStorage 中设置 token
    localStorage.setItem("token", token);
    }
}

//用于管理 shared，例如重载 shared 实例、获取 shared 实例等等
class SharedModule {
    static shared = new Shared();

    /**
        * 重载 shared
    */
    static overloadShared(shared) {
    SharedModule.shared = shared;
    }

    /**
        * 获取 shared 实例
    */
    static getShared() {
    return SharedModule.shared;
    }
}

export default SharedModule;
```

2. 在入口文件处注入 shared
```ts
// micro-app-vue/src/main.js
//...

/**
* 渲染函数
* 主应用生命周期钩子中运行/子应用单独启动时运行
*/
function render(props = {}) {
    // 当传入的 shared 为空时，使用子应用自身的 shared
    // 当传入的 shared 不为空时，主应用传入的 shared 将会重载子应用的 shared
    const { shared = SharedModule.getShared() } = props;
    SharedModule.overloadShared(shared);

    router = new VueRouter({
    base: window.__POWERED_BY_QIANKUN__ ? "/vue" : "/",
    mode: "history",
    routes,
    });

    // 挂载应用
    instance = new Vue({
    router,
    render: (h) => h(App),
    }).$mount("#app");
}
```

3. 修改子应用的 通讯页，使用 shared 实例获取 token
```ts
// micro-app-vue/src/pages/communication/index.vue
// 引入 SharedModule
import SharedModule from "@/shared";
import { ApiGetUserInfo } from "@/apis";

export default {
    name: "Communication",

    data() {
    return {
        userInfo: {}
    };
    },

    mounted() {
    const shared = SharedModule.getShared();
    // 使用 shared 获取 token
    const token = shared.getToken();

    // 未登录 - 返回主页
    if (!token) {
        this.$message.error("未检测到登录信息！");
        return this.$router.push("/");
    }

    this.getUserInfo(token);
    },

    methods: {
    async getUserInfo(token) {
        // ApiGetUserInfo 是用于获取用户信息的函数
        const result = await ApiGetUserInfo(token);
        this.userInfo = result.data.getUserInfo;
    }
    }
};
```

#### Shared通信(vuex)

1. 主应用向微应用传递store实例
```ts
registerMicroApps(
    [
        {
            name: "chai-project",
            entry: "//localhost:8080",
            container: '#yourContainer',
            activeRule: "/chaiQiankunTest/ffff",
            props: {
                store //共享主应用的store实例
            }
        }
    ],
    {
        beforeLoad: [
            app => {
                console.log("before load", app);
            }
        ], // 挂载前回调
        beforeMount: [
            app => {
                console.log("before mount", app);
            }
        ], // 挂载后回调
        afterUnmount: [
            app => {
                console.log("after unload", app);
            }
        ] // 卸载后回调
    }
)
```

2. 微应用使用主应用共享的store实例
```ts
import Vuex from 'vuex'
Vue.use(Vuex);
function render (props) {
const store = props.store;
// 在 render 中创建 VueRouter，可以保证在卸载微应用时，移除 location 事件监听，防止事件污染
router = new Router({
    // 运行在主应用中时，添加路由命名空间 /chaiQiankunTest/ffff
    base: window.__POWERED_BY_QIANKUN__ ? 'chaiQiankunTest/ffff' : '/',
    mode: 'history',
    routes
});

// 挂载应用
instance = new Vue({
    router,
    store,//主应用共享的store实例
    render: (h) => h(App)
}).$mount('#app');
}
```

3. 在微应用中将共享的store实例进行响应式设置

Vue.observable(store)

4. 子应用本身的store如何全局注册呢？

Vue.prototype.microStore = microStore;
